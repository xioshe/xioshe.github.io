<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机掷骰子吗？关于随机数的一些细节</title>
      <link href="2023/01/java-random/"/>
      <url>2023/01/java-random/</url>
      
        <content type="html"><![CDATA[<p>在计算机领域，随机数是一个十分重要的机制，除了模拟客观世界的随机现象，有一些场景本身就需要随机数，比如 AES 对称机密算法中需要一个随机数作为密钥，以及 TCP 连接”三次握手“时 TCP 头的 seq 字段应该初始化为随机值。对于人类来说，人脑无法凭空创造出随机数，至少无法证明构思的数字是一个随机数，人类只能借助硬币和骰子等工具来得到一个随机的数字。作为在计算方面比人脑更强大的计算机，能否创造出随机数呢，还是计算机也需要“骰子”呢？</p><h2 id="random-与真伪随机"><a class="markdownIt-Anchor" href="#random-与真伪随机"></a> Random 与真伪随机</h2><p>在需要随机数时，熟悉 Java 的开发者很容易基于 <code>java.util.Random</code> 写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> ri = random.nextInt();</span><br></pre></td></tr></table></figure><p>此外，也可以指定其它随机数字类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> rb = random.nextBoolean();</span><br><span class="line"><span class="keyword">long</span> rl = random.nextLong();</span><br><span class="line"><span class="keyword">float</span> rf = random.nextFloat();</span><br><span class="line"><span class="keyword">double</span> rd = random.nextDouble();</span><br><span class="line"><span class="keyword">byte</span>[] rndBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">random.nextBytes(rndBytes);</span><br></pre></td></tr></table></figure><p>阅读 Random 类的源代码，我们会发现这些 nextXXX 方法获取随机值时都会调用该类的另一个 next 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk 1.8 java.util.Random</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next 方法包含了 Random 类生成随机数的核心逻辑。不过，在解释这段代码之前，我们先了解一个前置知识——LCG 算法。</p><h3 id="lcg-算法"><a class="markdownIt-Anchor" href="#lcg-算法"></a> LCG 算法</h3><p>LCG（Linear congruential generator，线性同余生成器）算法是一种利用数学公式来计算随机数的算法，原理可以概括为一个简单的公式。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>X</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><msub><mi>X</mi><mi>n</mi></msub><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi></mrow><annotation encoding="application/x-tex">X_{n+1} = (aX_{n} + c)\ mod\ m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">m</span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 代表一个整数序列，是一系列随机数，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>X</mi><mi>n</mi></msub><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">0 \leq X_{n} &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是模数，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">0 &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 是乘数，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>a</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">0 &lt; a &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> 是增量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>c</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">0 \leq c &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是序列起始值，又称种子数，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>X</mi><mn>0</mn></msub><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">0 \leq X_{0} &lt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</li></ul><p>线性同余公式相当于将线性函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f(x)=ax+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> 的值对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 取模，然后将结果的余数作为新的输入来计算下一个余数，如此反复，得到的结果集构成了一个序列，这个序列的值分布相当分散，符合了随机数分布均匀的特点，因此可以用来生成随机数。LCG 算法正是基于这个序列实现了生成随机数的功能，但并非直接可用，还需要解决两个额外的问题。</p><p>首先，线性同余公式本身具备幂等性，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> 不变的情况下，对于相同的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，总能得到相同的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X_{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。一旦 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中出现重复值，序列中也会出现重复段，这将导致 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 呈现周期性的特点，而随机序列不应该有周期。为了解决这个问题，LGC 算法必须消除周期的影响。</p><table><thead><tr><th>参数</th><th>起始值</th><th>序列</th></tr></thead><tbody><tr><td>m = 9, a = 2, c = 0</td><td>1</td><td>1,2,4,8,7,5,1,…</td></tr><tr><td>m = 9, a = 2, c = 0</td><td>3</td><td>3,6,3,…</td></tr><tr><td>m = 9, a = 2, c = 0</td><td>5</td><td>5,1,2,4,8,7,5,…</td></tr><tr><td>m = 9, a = 4, c = 1</td><td>0</td><td>0,1,5,3,4,8,6,7,2,0,…</td></tr></tbody></table><p>不言自明，序列的周期由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> 的值控制，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 是序列中元素取值的上限，也就是周期范围的上限。调整这三个常数，设置一个很大的周期，比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，只在这个范围内取值，可以保证得到的数是随机数，而且这个范围也不算小，足以使用很长一段时间。</p><p>其次，线性同余的结果容易被逆向推算出来。两个连续的值可以推断出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>，多个连续的值可以猜测出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。一旦知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> ，就可以根据当前值计算出下一个值，这将导致严重的后果：下一个随机数可以被预测！解决起来也简单，只对外暴露 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X_{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 的部分数位，完整值仅在内部使用。一般会暴露高位，因为高位随机特点更鲜明。</p><p>解决了以上两个问题，就可以基于 LCG 算法实现一个随机数生成器，不考虑并发问题，代码比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> modulus = <span class="number">1L</span> &lt;&lt; <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> addend = <span class="number">0xBL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> seed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次计算后更新 seed</span></span><br><span class="line">    <span class="keyword">this</span>.seed = lcg(modulus, multiplier, addend, <span class="keyword">this</span>.seed);</span><br><span class="line">    <span class="comment">// seed 的有效位为 0 到 47，高 16 位为 0，右移 16 位代表仅返回 seed 的 16 到 47 位</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (seed &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">lcg</span><span class="params">(<span class="keyword">long</span> m, <span class="keyword">long</span> a, <span class="keyword">long</span> c, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (seed * a + c) % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LCG 算法是最古老最常见的伪随机数生成算法之一，因为其简便易行的特点，积极活跃于计算机世界之中，大部分编程语言都提供了 LCG 算法实现的随机数 API。</p><table><thead><tr><th>编程语言</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span></th><th>对外范围</th></tr></thead><tbody><tr><td>glibc（GCC）</td><td>2^31</td><td>1103515245</td><td>12345</td><td>位 30…0</td></tr><tr><td>java.util.Random</td><td>2^48</td><td>25214903917 (5DEECE66D 16 )</td><td>11</td><td>位 47…16</td></tr><tr><td>Virtual Pascal</td><td>2^32</td><td>134775813</td><td>1</td><td>位 63…32</td></tr></tbody></table><h3 id="javautilrandom"><a class="markdownIt-Anchor" href="#javautilrandom"></a> java.util.Random</h3><p>现在再来看 Random 类的 next 方法，大致与上面的 LCG 算法相同，细微之处有两点差异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk 1.8 java.util.Random</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong seed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> addend = <span class="number">0xBL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> mask = (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="comment">// 原子类循环 CAS，从而实现并发安全更新 seed 的值</span></span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        <span class="comment">// 相当于 nextseed = (oldseed * multiplier + addend) % (1L &lt;&lt; 48)</span></span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="comment">// nextInt() 方法传入的 bits 参数为 32</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，Random 类为了支持并发，使用原子类型 AtomicLong 保存 seed 的值，辅以<strong>循环 CAS</strong> 的方式保证了并发环境下每个线程更新 seed 的操作都是原子性操作，不会存在多线程互相覆盖的情况。<strong>循环 CAS</strong> 是一种常见的并发技巧，<code>seed.compareAndSet(oldseed, nextseed)</code> 更新时如果 seed 中的值不等于 oldseed，就会放弃更新并返回 false，于是重新进入 do-while 循环体，获取最新的 seed 再次计算。循环 CAS 确保了线程的操作一定基于共享变量的最新状态进行，并保证线程对共享变量的更新一定有效。</p><p>其次，Random 采取了 <strong>power of two</strong> 的技巧来优化模运算。当模数为 2 的 n 次方时，可以用位与运算来替代模运算，基本公式为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mi>i</mi><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i\ mod\ 2^{n} = i\ \&amp;\ (2^{n} - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，比如 <code>i % 8 == i &amp; 7</code>、<code>i % 16 == i &amp; 15</code>、<code>i % (1 &lt;&lt; 16) == i &amp; ((1 &lt;&lt; 16) - 1)</code>。因为 2 的 n 次方减 1 的二进制表示是连续 n-1 个 1，相当于一个掩码，一个数与掩码位与的结果就是这个数在掩码所有为 1 的数位上的值，所以右边的位与计算可以求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这个范围内的值。对于左边的模运算，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 的部分都会被除去，结果也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 这个范围内的值。两种计算方式等价，但 CPU 执行位与指令时比执行模运算相关指令更快，可以提高计算效率。这个优化技巧的应用很广，比如 HashMap 也有用到。HashMap 内部数组初始化时长度固定为 2 的整数幂，扩容时也是成倍扩容，正是为了保证数组长度一定是 2 的 n 次方，从而在计算 key 的数组下标时可以将模运算替换为位与操作。</p><h3 id="种子"><a class="markdownIt-Anchor" href="#种子"></a> 种子</h3><p>LGC 算法中，在常量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span> 确定的情况下，输入相同的起始值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就能得到相同的序列，这样随机数生成器就有了“回放”的功能。Random 类也支持“回放”功能，可以在构造函数传入一个 long 类型的“种子”。两个不同 Random 对象，种子相同，生成的随机数序列也相同。同一个种子，同一个序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> seed = -<span class="number">229985452L</span>;</span><br><span class="line">Random rnd1 = <span class="keyword">new</span> Random(seed);</span><br><span class="line">Random rnd2 = <span class="keyword">new</span> Random(seed);</span><br><span class="line">assertThat(rnd1.nextInt()).isEqualTo(rnd2.nextInt());</span><br><span class="line">assertThat(rnd1.nextBoolean()).isEqualTo(rnd2.nextBoolean());</span><br><span class="line">assertThat(rnd1.nextLong()).isEqualTo(rnd2.nextLong());</span><br><span class="line">assertThat(rnd1.nextFloat()).isEqualTo(rnd2.nextFloat());</span><br><span class="line">assertThat(rnd1.nextDouble()).isEqualTo(rnd2.nextDouble());</span><br></pre></td></tr></table></figure><p>基于“回放”的特点，可以实现一些比较奇怪的代码，比如“生成的随机字符串竟是一个有意义的单词”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_string_equals_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> seed = -<span class="number">229985452L</span>;</span><br><span class="line">    assertThat(randomString(seed)).isEqualTo(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">randomString</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    Random rnd = <span class="keyword">new</span> Random(seed);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = rnd.nextInt(<span class="number">27</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#x27;`&#x27; 符号是 ascii 表里小写字母 &#x27;a&#x27; 的前一位</span></span><br><span class="line">        sb.append((<span class="keyword">char</span>) (<span class="string">&#x27;`&#x27;</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随机生成了 hello 字符串！看起来十分新奇，实际上这代码中的随机数种子 <code>-229985452L</code> 是提前计算好的，换个值就不成立了。这种“新奇”只是随机数种子的应用。</p><p>源码上，如果 Random 类的构造函数传入了参数 seed，还会先进行一次混淆处理，这样保证了随机性，同时也保证种子数不会超过模数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk 1.8 java.util.Random</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getClass() == Random.class)</span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(initialScramble(seed));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// subclass might have overriden setSeed</span></span><br><span class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">initialScramble</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (seed ^ multiplier) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有指定种子，Random 类的策略是随机生成一个新种子。生成新种子时考虑了系统时间，这是一个随机量，同时还有一个原子类型 seedUniquifier 用于记录上一次生成的种子，新的种子由这两个因素决定。原子变量 seedUniquifier 采用了<strong>循环 CAS</strong> 的方式保证并发安全更新，其初始值为一个魔法值，计算新种子时的乘数 <code>181783497276652981L</code> 也是一个魔法值，这两个魔法值来自注释上的那篇论文 <em>L’Ecuyer, “Tables of Linear Congruential Generators of Different Sizes and Good Lattice Structure”, 1999</em>。Random 的种子生成算法参考了这篇论文，保证了并发调用时生成的随机数种子也具备很好的随机性。（实际上根据这篇论文，乘数的值应该为 <code>1181783497276652981L</code>，这里少了最高位的 1，可能是复制时漏掉了。这个 bug 在 JDK 11 中已经修复。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong seedUniquifier</span><br><span class="line">        = <span class="keyword">new</span> AtomicLong(<span class="number">8682522807148012L</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">seedUniquifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// L&#x27;Ecuyer, &quot;Tables of Linear Congruential Generators of</span></span><br><span class="line">    <span class="comment">// Different Sizes and Good Lattice Structure&quot;, 1999</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> current = seedUniquifier.get();</span><br><span class="line">        <span class="keyword">long</span> next = current * <span class="number">181783497276652981L</span>;</span><br><span class="line">        <span class="keyword">if</span> (seedUniquifier.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具备“回放”功能的随机数生成器用途也非常广泛。许多随机地图的游戏，比如文明、Minecraft、饥荒，玩家之间会共享一些趣味性很高的地图，而共享的途径就是一个称为地图种子的数字。不难推测，这些游戏都是用了随机数生成器生成的随机序列作为游戏地图的初始化参数，利用随机数来构建各个元素，从而创造出一个随机的世界。如果载入游戏时指定了地图种子，能可以生成一个既定的参数列表，呈现出一个已知的地图；如果没有指定，系统会随机生成一个地图种子，创造出一个随机地图。某种意义上，随机数种子就像游戏世界创世之初的奇点，计算机从这个奇点中孕育出了一个全新的世界。</p><h3 id="真伪随机"><a class="markdownIt-Anchor" href="#真伪随机"></a> 真伪随机</h3><p>除了 LGC 算法，常用的随机数生成算法还有平方取中法、梅森旋转算法等，都是利用数学生成周期性序列的方法，我们称之为伪随机数。因为这些随机序列看起来随机，实际上并不随机，受限于有限的状态，具备周期性这个显著的缺点。</p><blockquote><p>冯·诺依曼曾经断言：「任何用数学方法生成随机数的尝试都不合理。」</p></blockquote><p>与数学上的伪随机数相对，现实世界在自然随机性中产生的随机数，称为真随机数。真随机不仅看起来随机，实际上也随机。真随机序列分布均匀，不可预测，还没有周期，是真正符合传统认知的随机数。产生真随机数的机制没有幂等性，所有条件相同的情况下，输出也可能不相等。这就是真随机的魅力。无论两次投掷的角度和力道如何相同，物理学灵巧的手指也可能把骰子拨到一个截然不同的点数。在安全领域，幂等性是所有伪随机数生成算法无法掩盖的阿喀琉斯之踵。因为图灵机本身就是充满确定性的工具，只要计算机还在采用图灵机作为计算模型，就无法凭空创造出不确定性的真随机。</p><p>既然如此，计算机就无法生成真随机数了吗？</p><p>计算机系统的设计者们采取了一个十分巧妙的方式，既然无法凭空创造出真随机，那就直接使用现实世界的随机源。计算机可以直接使用的真随机源其实并不多：</p><ul><li><p>时钟，每一个操作发生时的纳秒时间戳具备很强的随机性。前面 Random 类生成随机种子时就是利用了时钟的随机性。</p></li><li><p>硬件，计算机与外界交互都是依托于硬件，鼠标的移动距离和间隔、键盘的敲击间隔、网卡等待时长、磁盘调度间隔，都是非常随机的数据。这里列出一些可以作为计算机真随机的来源：</p><ul><li>键盘</li><li>鼠标</li><li>中断请求</li><li>机械硬盘寻道时长</li><li>网络活动</li><li>麦克风</li><li>网络摄像头</li><li>触摸屏</li><li>WIFI</li><li>以及一些特殊硬件</li></ul><p>计算机借助这些硬件，从现实世界汲取随机性，生成真随机数。这些硬件便是计算机的“骰子”。</p></li></ul><h3 id="devrandom"><a class="markdownIt-Anchor" href="#devrandom"></a> /dev/random</h3><p>Unix 系的系统有一个 <code>/dev/random</code> 文件，读取到的内容是一些随机字节，这些随机字节都来自系统的熵池。所谓熵池，通俗讲就是一个随机字节的资源池。这个池子里存放着系统从硬件采集来的真随机信息，当程序需要真随机数时可以直接从池子取数。<code>/dev/random</code> 是系统提供的熵池入口，还有另一个入口 <code>/dev/urandom</code>，也起着同样的作用。</p><p>既然是资源，自然可能耗尽，这两个熵池入口的主要区别，就在于资源耗尽时的处理机制。</p><ul><li><code>/dev/random</code> 在资源耗尽时会阻塞，直到系统重新采集到足够的随机字节，阻塞间隔可能长达几分钟。记住，<code>/dev/random</code> 存在线程阻塞风险，后面会介绍这个问题。</li><li><code>/dev/urandom</code> 在资源耗尽时不会阻塞，而是退化为伪随机数生成器。</li></ul><p>在一些编程习惯里，<code>/dev/random</code> 用于获取随机种子，也可用于生成高随机性的公钥或一次性密码本，而 <code>/dev/urandom</code> 则用于获取随机数。Linux 系统的程序在需要真随机数时，如果没有其它获取方式，基本上都会考虑从熵池中获取。</p><p>在容器化的浪潮中，熵池又面临着新的问题。熵池的数据来自硬件，容器启动时熵池是空的，需要一点时间来积累。如果启动时就需要读取熵池，会导致阻塞或启动失败，比如 Docker 日志 <strong>crypto/rand: blocked for 60 seconds waiting to read random data from the kernel</strong>，就是因为容器刚启动熵池资源不够，Docker 只能暂停一分钟给容器以搜集时间。此时可以考虑主动进行熵注入，一般有两个方向：</p><ul><li>在容器外用专门的熵服务器进行“授粉”；</li><li>在容器内利用 <strong>haveged</strong> 进程为熵池提供数据。</li></ul><h2 id="securerandom-与密码学安全的伪随机序列"><a class="markdownIt-Anchor" href="#securerandom-与密码学安全的伪随机序列"></a> SecureRandom 与密码学安全的伪随机序列</h2><p>密码学领域，对随机数除了随机性要求，还必须保证不可预测。大多数伪随机数生成算法都不符合要求。如 LCG 算法，知道了初始种子，就等于知道了确切的随机序列，攻击者就可以根据当前随机值预测出下一个随机数。LCG 算法实现都不得不将种子作为程序的内部状态保存起来，如 Random 类的 seed 实例属性，就保存着当前的随机数种子。这些内部状态存在着被泄露的可能，攻击者可以通过反射、Unsafe 等方式获取到种子数。密码学需要更不确定的随机数。</p><p>对此，JDK 提供了 <code>java.security.SecureRandom</code> 作为更安全的随机数生成器。</p><h3 id="securerandom-的使用"><a class="markdownIt-Anchor" href="#securerandom-的使用"></a> SecureRandom 的使用</h3><p>使用方面，SecureRandom 继承自 <code>java.util.Random</code>，提供的 API 与 Random 大致相同，但有一个功能与 Random 截然相反。SecureRandom 类虽然支持指定种子，但种子只是对现有种子的补充，而非完全替代，因此不具备 Random 的“回放”功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rndBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">SecureRandom sr1 = <span class="keyword">new</span> SecureRandom(rndBytes);</span><br><span class="line">SecureRandom sr2 = <span class="keyword">new</span> SecureRandom(rndBytes);</span><br><span class="line">assertThat(sr1.nextInt()).isNotEqualTo(sr2.nextInt());</span><br><span class="line">assertThat(sr1.nextLong()).isNotEqualTo(sr2.nextLong());</span><br><span class="line">assertThat(sr1.nextFloat()).isNotEqualTo(sr2.nextFloat());</span><br><span class="line">assertThat(sr1.nextDouble()).isNotEqualTo(sr2.nextDouble());</span><br></pre></td></tr></table></figure><h3 id="securerandom-的实现"><a class="markdownIt-Anchor" href="#securerandom-的实现"></a> SecureRandom 的实现</h3><p>实现适合密码安全领域的随机数生成器，通常有两个方向：</p><ul><li><p>直接使用真随机数生成器生成的随机数，比如前面提到的系统熵池；</p></li><li><p>采取满足密码学需求的伪随机数算法，并使用真随机数做种子。</p></li></ul><p>SecureRandom 类在实现上兼顾了上述两种思路，既读取系统熵池，也内置了一个伪随机数算法，最终提供的随机数是两种生成方式结果的混合。</p><p>SecureRandom 类的大致结构图如下：</p><p><img src="https://raw.githubusercontent.com/xioshe/img-oss/master/img/SecureRandom%20%E7%BB%93%E6%9E%84.drawio.png" alt="SecureRandom 结构" /></p><p>以下分别介绍这些组成部份。</p><p>首先，SecureRandom 在设计上就支持多种随机数生成算法，利用 <strong>SPI 机制</strong>将算法变为可配置式。SecureRandom 重写了 next 方法，仅仅负责将 <code>nextBytes()</code> 方法提供的随机字节转换为 int 整数，将生存随机数据的职责交给了 <code>nextBytes()</code>，而 <code>nextBytes()</code> 则调用 SPI 实现类 SecureRandomSpi 来获取随机字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureRandom</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Random</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> SecureRandomSpi secureRandomSpi = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> numBits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 职责转移之后 next 方法只是一个根据字节数组</span></span><br><span class="line">        <span class="comment">// 生成对应 int 类型整数的算法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numBytes = (numBits+<span class="number">7</span>)/<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[numBytes];</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        nextBytes(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numBytes; i++) &#123;</span><br><span class="line">            next = (next &lt;&lt; <span class="number">8</span>) + (b[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next &gt;&gt;&gt; (numBytes*<span class="number">8</span> - numBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextBytes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由 SPI 实现类负责提供随机字节</span></span><br><span class="line">        secureRandomSpi.engineNextBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，要了解 SecureRandom 的原理，需要深入了解 SecureRandomSpi 的实现类。JDK 为 SecureRandomSpi 提供了四种实现。</p><ul><li><p>SHA1PRNG，内置的伪随机数生成算法，基于 SHA1 哈希算法生成随机数，对应实现类为 <code>sun.security.provider.SecureRandom</code>。SHA1PRNG 算法是 Sun 公司的专利算法，以 OracleJDK 为准，其它 JDK 平台的实现不一致。</p></li><li><p>NativePRNG，使用系统熵池，对应实现类为 <code>sun.security.provider.NativePRNG</code>。Unix-Like 系统和 Windows 的实现不一致，Unix 系列的系统使用 <code>/dev/random</code> 作为种子来源，<code>/dev/urandom</code> 作为真随机数来源，Windows 平台的 NativePRNG 类则不具备实际意义，只是一个不提供任何功能的 dummy 实现，Windows 的 SecureRandom 类会优先使用 SHA1PRNG 算法，只在获取种子时通过 NativeSeedGenerator 类中调用系统 API CryptoAPI 来获取种子。</p></li><li><p>NativePRNGBlocking，NativePRNG 的特殊版本，对应实现类 <code>sun.security.provider.NativePRNG$Blocking</code>，指定 <code>/dev/random</code> 同时作为种子来源和真随机数来源。</p></li><li><p>NativePRNGNonBlocking，NativePRNG 的特殊版本，对应实现类 <code>sun.security.provider.NativePRNG$NonBlocking</code>，指定 <code>/dev/urandom</code> 同时作为种子来源和真随机数来源。</p></li></ul><p>SecureRandom 在构造函数初始化 SecureRandomSpi 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureRandom</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Random</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SecureRandomSpi secureRandomSpi = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecureRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">0</span>);</span><br><span class="line">        getDefaultPRNG(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecureRandom</span><span class="params">(<span class="keyword">byte</span> seed[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">0</span>);</span><br><span class="line">        getDefaultPRNG(<span class="keyword">true</span>, seed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 初始化 secureRandomSpi */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getDefaultPRNG</span><span class="params">(<span class="keyword">boolean</span> setSeed, <span class="keyword">byte</span>[] seed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用 SPI 机制获取实现类</span></span><br><span class="line">        String prng = getPrngAlgorithm();</span><br><span class="line">        <span class="keyword">if</span> (prng == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有配置，使用 SHA1PRNG 实现</span></span><br><span class="line">            <span class="comment">// bummer, get the SUN implementation</span></span><br><span class="line">            prng = <span class="string">&quot;SHA1PRNG&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.secureRandomSpi = <span class="keyword">new</span> sun.security.provider.SecureRandom();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果有配置，则根据配置选择具体的 NativePRNG 实现</span></span><br><span class="line">                SecureRandom random = SecureRandom.getInstance(prng);</span><br><span class="line">                <span class="keyword">this</span>.secureRandomSpi = random.getSecureRandomSpi();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException nsae) &#123;</span><br><span class="line">                <span class="comment">// never happens, because we made sure the algorithm exists</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(nsae);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的一步在 <code>getDefaultPRNG()</code> 方法中，<code>String prng = getPrngAlgorithm()</code> 从 JDK 已注册的 Provider 列表中查找第一个类型为 SecureRandom 的 Provider，获取其名称，然后根据该名称去实例化 secureRandomSpi。</p><p>负责注册 Provier 的类为 <code>sun.security.provider.SunEntries</code>，在其 <code>putputEntries()</code> 方法中会根据系统配置和系统类型注册不同的 Provider。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SunEntries</span> </span>&#123;</span><br><span class="line">    <span class="comment">// seedSource 来源于系统配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String seedSource;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putEntries</span><span class="params">(Map&lt;Object, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Windows 平台 JDK 此处返回 false</span></span><br><span class="line">        <span class="keyword">boolean</span> nativeAvailable = NativePRNG.isAvailable();</span><br><span class="line">        <span class="keyword">boolean</span> useNativePRNG = seedSource.equals(<span class="string">&quot;file:/dev/urandom&quot;</span>) ||</span><br><span class="line">            seedSource.equals(<span class="string">&quot;file:/dev/random&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nativeAvailable &amp;&amp; useNativePRNG) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;SecureRandom.NativePRNG&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sun.security.provider.NativePRNG&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;SecureRandom.SHA1PRNG&quot;</span>,</span><br><span class="line">             <span class="string">&quot;sun.security.provider.SecureRandom&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (nativeAvailable &amp;&amp; !useNativePRNG) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;SecureRandom.NativePRNG&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sun.security.provider.NativePRNG&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Windows 平台 JDK 此处也返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (NativePRNG.Blocking.isAvailable()) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;SecureRandom.NativePRNGBlocking&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sun.security.provider.NativePRNG$Blocking&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Windows 平台 JDK 此处也返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (NativePRNG.NonBlocking.isAvailable()) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;SecureRandom.NativePRNGNonBlocking&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sun.security.provider.NativePRNG$NonBlocking&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略不相关配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seedSource 属性的值来自系统配置，尝试从命令行参数和配置文件中获取熵源偏好。这是个出镜率很高的属性，后面将看到许多类都会参考 seedSource 的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String seedSource;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    seedSource = AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Java 启动命令</span></span><br><span class="line">                String egdSource = System.getProperty(<span class="string">&quot;java.security.egd&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (egdSource.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> egdSource;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// JDK 配置项</span></span><br><span class="line">                egdSource = Security.getProperty(<span class="string">&quot;securerandom.source&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (egdSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> egdSource;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合起来，seedSource 代表系统配置，NativePRNG 类的 <code>isXXXAvailable()</code> 方法代表平台环境，SunEntries 类结合两者进行注册，SecureRandom 则会在初始化时读取对应的注册项，从而实现动态加载 secureRandomSpi。</p><p>整个过程中，开发者唯一可控的就是系统配置。如同代码展示的一样，有两个配置项可以决定 SecureRandom 采取的实现：</p><ul><li>通过 Java 启动参数 <code>-Djava.security.egd=file:/dev/xxx</code> 指定一个熵池文件，使用 NativePRNG；</li><li>通过 JDK 目录下 <code>conf/securety/java.security</code> 文件（或者 JRE 目录 <code>jre/lib/security/java.security</code>）设置配置项 <code>securerandom.source</code> 为 <code>file:/dev/random</code> 或 <code>file:/dev/urandom</code>，使用 NativePRNG，默认配置为 <code>/dev/random</code>。（在 JDK 1.8 之前的版本有个 BUG，使用 urandom 需要设置为 <code>file:/dev/./urandom</code>，JDK 8 已经修复。）</li></ul><p>显然，Java 命令行参数的优先级更高。</p><p>Windows 平台的 JDK 因为 SunEntries 的 putEntries 方法没有注册对应的 NativePRNG，会直接采取 SHA1PRNG 实现。</p><h3 id="nativeprng-的实现"><a class="markdownIt-Anchor" href="#nativeprng-的实现"></a> NativePRNG 的实现</h3><p>NativePRNG 有三种实现类，但大同小异，都是依赖于内部单例对象 RandomIO 进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NativePRNG</span> <span class="keyword">extends</span> <span class="title">SecureRandomSpi</span> </span>&#123;</span><br><span class="line">    <span class="comment">// RandomIO 的种类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Variant</span> </span>&#123;</span><br><span class="line">        MIXED, BLOCKING, NONBLOCKING</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RandomIO 的单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RandomIO INSTANCE = initIO(Variant.MIXED);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据类型创建不同的 RandomIO 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RandomIO <span class="title">initIO</span><span class="params">(<span class="keyword">final</span> Variant v)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineSetSeed</span><span class="params">(<span class="keyword">byte</span>[] seed)</span> </span>&#123;</span><br><span class="line">        INSTANCE.implSetSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pseudo random bytes</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">engineNextBytes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        INSTANCE.implNextBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get true random bytes</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] engineGenerateSeed(<span class="keyword">int</span> numBytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE.implGenerateSeed(numBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecureRandomSpi 将获取随机种子的功能和获取随机字节的功能分为了两个不同的方法，因此 NativePRNG 在实现时也分别调用 RandomIO 的不同方法。RandomIO 读取系统熵池也会区分不同文件，根据随机种子文件来源和随机数文件来源的不同组合分为三类，分别对应枚举类 <code>Variant</code> 的三种类型。</p><ul><li>MIXED，默认情况，对应 NativePRNG 类本身，随机种子文件默认为 <code>/dev/random</code>，随机数文件则固定使用 <code>/dev/urandom</code>。其中，随机种子文件可以更改，决定因素正是 <code>SunEntries.seedSource</code> 属性，因此可以手动配置。随机数文件无法更改。</li><li>BLOCKING，对应内部类 <code>NativePRNG$Blocking</code>，同时使用 <code>/dev/random</code> 作为随机种子文件和随机数文件。</li><li>NONBLOCKING，对应内部类 <code>NativePRNG$NonBlocking</code>，同时使用 <code>/dev/urandom</code> 作为随机种子文件和随机数文件。</li></ul><table><thead><tr><th>类型</th><th>随机种子文件</th><th>随机数文件</th></tr></thead><tbody><tr><td>MIXED</td><td>/dev/random（默认配置，可以修改）</td><td>/dev/urandom</td></tr><tr><td>BLOCKING</td><td>/dev/random</td><td>/dev/random</td></tr><tr><td>NONBLOCKING</td><td>/dev/urandom</td><td>/dev/urandom</td></tr></tbody></table><p>RandomIO 封装了对熵池文件的读取操作，可以从系统熵池读取对应的真随机字节，但并非完全依赖于系统熵池。RandomIO 内部还持有了一个 SHA1PRNG 伪随机算法的实例（即 <code>sun.security.provider.SecureRandom</code>），对外提供随机字节时会结合系统熵池的真随机数据和 SHA1PRNG 算法生成的伪随机数据，确切地说是对两者采取异或运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomIO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get pseudo random bytes</span></span><br><span class="line">    <span class="comment">// read from &quot;next&quot; and XOR with bytes generated by the</span></span><br><span class="line">    <span class="comment">// mixing SHA1PRNG</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">implNextBytes</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简化代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 SHA1PRNG 算法填充 data 数组</span></span><br><span class="line">            getMixRandom().engineNextBytes(data);</span><br><span class="line">            <span class="comment">// 从系统熵池读取真随机随机字节，复制进 localBuffer</span></span><br><span class="line">            ensureBufferValid();</span><br><span class="line">            localBuffer = Arrays.copyOfRange(...);</span><br><span class="line">            <span class="comment">// 混合两个随机数组，异或运算</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len &lt; data.length) &#123;</span><br><span class="line">                data[ofs] ^= localBuffer[localofs];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProviderException(<span class="string">&quot;nextBytes() failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上述两小节的内容，我们可以知道 SecureRandom 的大致逻辑。</p><p>SecureRandom 类采取了配置化的设计，可以在两大类随机数生成算法中选择：SHA1PRNG 是偏向计算的伪随机数算法，NativePRNG 则是基于系统熵池的算法，还可以配置为读取不同的系统熵池以避免阻塞。</p><p>Unix-Like 平台默认使用 NativePRNG 算法，也就是以 <code>/dev/random</code> 和 <code>/dev/urandom</code> 两个文件作为熵源。即使明确指定使用系统熵池，SecureRandom 也并非直接返回从熵池读取到的随机字节，还会用 SHA1PRNG 算法来掺入随机因子。</p><h3 id="sha1prng-的实现"><a class="markdownIt-Anchor" href="#sha1prng-的实现"></a> SHA1PRNG 的实现</h3><p>对应实现类为 <code>sun.security.provider.SecureRandom</code>，与 <code>java.security.SecureRandom</code> 同名，后续为了区分，均称呼其为 SHA1PRNG。SHA1PRNG 继承自 SecureRandomSpi，利用哈希算法生成随机序列，换而言之，这是一个伪随机数生成器。上文曾提及，有两种方式生成密码学安全的随机数，其中一种是“真随机种子 + 密码学安全的伪随机算法”，这正是 SHA1PRNG 的主要思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** JDK 8 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureRandom</span> <span class="keyword">extends</span> <span class="title">SecureRandomSpi</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 生成随机种子 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] engineGenerateSeed(<span class="keyword">int</span> numBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[numBytes];</span><br><span class="line">        <span class="comment">// 调用 SeedGenerator</span></span><br><span class="line">        SeedGenerator.generateSeed(b);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 懒加载 seeder 的技巧 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SeederHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问 seeder 时会触发类初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SecureRandom seeder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            seeder = <span class="keyword">new</span> SecureRandom(SeedGenerator.getSystemEntropy());</span><br><span class="line">            <span class="keyword">byte</span> [] b = <span class="keyword">new</span> <span class="keyword">byte</span>[DIGEST_SIZE];</span><br><span class="line">            <span class="comment">// 调用 SeedGenerator</span></span><br><span class="line">            SeedGenerator.generateSeed(b);</span><br><span class="line">            seeder.engineSetSeed(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">engineNextBytes</span><span class="params">(<span class="keyword">byte</span>[] result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果没有提供种子，第一次调用时 state 就会为 null</span></span><br><span class="line">        <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] seed = <span class="keyword">new</span> <span class="keyword">byte</span>[DIGEST_SIZE];</span><br><span class="line">            <span class="comment">// 注意上面注释，此处会调用 SeedGenerator</span></span><br><span class="line">            SeederHolder.seeder.engineNextBytes(seed);</span><br><span class="line">            state = digest.digest(seed);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略后续代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SHA1PRNG 类的代码主要是对于 SHA1 哈希算法的运用，我们重点关注 SeedGenerator。不管是生成种子还是生成随机字节，都会调用种子生成器 SeedGenerator 的静态方法 <code>generateSeed()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** JDK 8 */</span></span><br><span class="line"><span class="keyword">package</span> sun.security.provider;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SeedGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SeedGenerator instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSeed</span><span class="params">(<span class="keyword">byte</span>[] result)</span> </span>&#123;</span><br><span class="line">        instance.getSeedBytes(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getSeedBytes</span><span class="params">(<span class="keyword">byte</span>[] result)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SeedGenerator 是个抽象类，有两种子类。</p><ul><li><code>ThreadedSeedGenerator</code>，启动多个子线程，利用子线程产生的随机噪声生成随机数据。这种实现不依赖外部文件，移植性较高。</li><li><code>URLSeedGenerator</code>，从指定文件中读取字节。这种实现涉及到外部文件，需要系统保证功能一致，移植性较差。<ul><li><code>NativeSeedGenerator</code>，Unix-Like 系统与 URLSeedGenerator 实现一致，从系统熵池文件读取随机字节，Windows 系统则使用 MS CryptoAPI 来生成随机字节。</li></ul></li></ul><p>SeedGenerator 类中，会对静态属性 instance 进行初始化，初始化时也会参考“老朋友” <code>SunEntries.seedSource</code> 的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// here!</span></span><br><span class="line">    String egdSource = SunEntries.getSeedSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (egdSource.equals(SunEntries.URL_DEV_RANDOM) ||</span><br><span class="line">        egdSource.equals(SunEntries.URL_DEV_URANDOM)) &#123;</span><br><span class="line">        <span class="comment">// 如果使用系统熵池，则对应 NativeSeedGenerator</span></span><br><span class="line">        instance = <span class="keyword">new</span> NativeSeedGenerator(egdSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (egdSource.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 非系统熵池文件作为随机源</span></span><br><span class="line">        instance = <span class="keyword">new</span> URLSeedGenerator(egdSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fall back to ThreadedSeedGenerator 兜底</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> ThreadedSeedGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码层次比较清晰，先尝试获取系统配置，如果配置中指定了随机种子文件，就会构造 NativeSeedGenerator 对象；如果没有配置或者初始化失败，就会构建一个移植性最好的 ThreadedSeedGenerator 对象。</p><p>使用 SHA1PRNG 算法就不会阻塞了吗？显然，如果指定了 seedSource，还是可能读取 <code>/dev/random</code> 或 <code>/dev/urandom</code>，仍然可能阻塞。</p><p>至此，我们可以对 Windows 平台的安全随机工具进行总结。由于 Windows 平台没有提供熵池接口，无法使用 NativePRNG 算法，因此默认使用的是 SHA1PRNG 算法，并且 SeedGenerator 使用的是基于系统 API 的 NativeSeedGenerator。</p><h3 id="需要使用-securerandomgetinstancestrong-吗"><a class="markdownIt-Anchor" href="#需要使用-securerandomgetinstancestrong-吗"></a> 需要使用 SecureRandom.getInstanceStrong() 吗？</h3><p>SecureRandom 类提供了许多静态工厂方法，用于快速获取指定的随机数生成器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecureRandom <span class="title">getInstance</span><span class="params">(String algorithm)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecureRandom <span class="title">getInstance</span><span class="params">(String algorithm, String provider)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecureRandom <span class="title">getInstance</span><span class="params">(String algorithm, Provider provider)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecureRandom <span class="title">getInstanceStrong</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>三种 <code>getInstance()</code> 方法只是普通的工厂方法，用于指定随机数算法，比如指定为 SHA1PRNG、NativePRNG、NativePRNGBlocking、NativePRNGNonBlocking。对于后两种算法而言，由于不是默认算法之一，主动指定是唯一的使用入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr1 = SecureRandom.getInstance(<span class="string">&quot;NativePRNGBlocking&quot;</span>);</span><br><span class="line">System.out.println(sr1.nextInt());</span><br><span class="line">System.out.println(sr1.nextInt());</span><br><span class="line">System.out.println(sr1.nextInt());</span><br></pre></td></tr></table></figure><p>比较特殊的是 <code>getInstanceStrong()</code>，从方法名上看，似乎是安全性比较高的随机数生成器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecureRandom <span class="title">getInstanceStrong</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    String property = Security.getProperty(<span class="string">&quot;securerandom.strongAlgorithms&quot;</span>);</span><br><span class="line">    String remainder = property;</span><br><span class="line">    <span class="keyword">while</span> (remainder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Matcher m;</span><br><span class="line">        <span class="comment">// 正则表达式匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((m = StrongPatternHolder.pattern.matcher(remainder)).matches()) &#123;</span><br><span class="line">            String alg = m.group(<span class="number">1</span>);</span><br><span class="line">            String prov = m.group(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (prov == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> SecureRandom.getInstance(alg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> SecureRandom.getInstance(alg, prov);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException |</span><br><span class="line">                     NoSuchProviderException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 出错了换下一组配置继续匹配</span></span><br><span class="line">            remainder = m.group(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            remainder = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchAlgorithmException(</span><br><span class="line">        <span class="string">&quot;No strong SecureRandom impls available: &quot;</span> + property);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码，该方法从安全配置中获取 <code>securerandom.strongAlgorithms</code> 属性，然后从该配置值中提取算法和实现，最后用 <code>getInstance()</code> 工厂方法构建实例。而 <code>securerandom.strongAlgorithms</code> 配置在哪呢，就在前面出现过的 JDK 配置文件 <code>java.security</code> 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cat java.security | grep <span class="string">&#x27;securerandom.strongAlgorithms&#x27;</span></span>                 </span><br><span class="line">securerandom.strongAlgorithms=NativePRNGBlocking:SUN,DRBG:SUN</span><br></pre></td></tr></table></figure><p>默认的算法为 NativePRNGBlocking，我们已经知道该算法以 <code>/dev/random</code> 同时作为随机种子文件和随机数文件。</p><p>所以，需要使用 <code>SecureRandom.getInstanceStrong()</code> 吗？<code>getInstanceStrong()</code> 也是使用了系统熵池文件作为随机源，并非真的更安全，与普通构造函数创造的对象没什么明显区别。相反，由于使用了 <code>/dev/random</code>，存在熵池耗尽而阻塞的可能。</p><h3 id="securerandom-的阻塞问题"><a class="markdownIt-Anchor" href="#securerandom-的阻塞问题"></a> SecureRandom 的阻塞问题</h3><p>由于 SecureRandom 在某些情况下会使用系统熵池 <code>/dev/random</code>，存在因为熵池耗尽而阻塞的可能性。这种阻塞严重时会持续几分钟，这对于系统性能的影响十分明显，我们必须尽量避免这种情况。</p><p>以 Linux 系统的 JDK 为例，以下情况 SecureRandom 可能阻塞：</p><ul><li><code>getInstance(&quot;NativePRNGBlocking&quot;)</code> 指定使用 NativePRNGBlocking 算法，此时生成随机数或生成随机种子时都可能阻塞，类似的情况还有  <code>SecureRandom.getInstanceStrong()</code> 方法；</li><li>默认情况下，也就是使用 NativePRNG 算法的 MIXED 模式，生成随机种子时可能阻塞（调用 <code>generateSeed(int numBytes)</code> 方法）；</li><li>使用 SHA1PRNG 算法时，如果采用系统默认配置，内部的种子生成器的实际类型是使用了 <code>/dev/random</code> 的 NativeSeedGenerator，存在阻塞的可能性。</li></ul><p>针对后面两种默认配置的阻塞情况，可以手动更换随机种子源为 <code>/dev/random</code>，比如在 JVM 启动命令中指定 <code>-Djava.security.egd=file:/dev/urandom</code>，或者修改 JDK 配置文件 java.security 为 <code>securerandom.source=file:/dev/urandom</code>。</p><p>SecureRandom 发生阻塞时，可以通过 <code>jstack</code> 命令可以获取阻塞线程的栈，大致如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f894c009000 nid=0x1129 runnable [0x00007f8952aa9000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at java.io.FileInputStream.readBytes(Native Method)</span><br><span class="line">    at java.io.FileInputStream.read(FileInputStream.java:255)</span><br><span class="line">    at sun.security.provider.NativePRNG$RandomIO.readFully(NativePRNG.java:424)</span><br><span class="line">    at sun.security.provider.NativePRNG$RandomIO.ensureBufferValid(NativePRNG.java:525)</span><br><span class="line">    at sun.security.provider.NativePRNG$RandomIO.implNextBytes(NativePRNG.java:544)</span><br><span class="line">    - locked &lt;0x000000076c77cb28&gt; (a java.lang.Object)</span><br><span class="line">    at sun.security.provider.NativePRNG$RandomIO.access$400(NativePRNG.java:331)</span><br><span class="line">    at sun.security.provider.NativePRNG$Blocking.engineNextBytes(NativePRNG.java:268)</span><br><span class="line">    at java.security.SecureRandom.nextBytes(SecureRandom.java:468)</span><br><span class="line">    at java.security.SecureRandom.next(SecureRandom.java:491)</span><br><span class="line">    at java.util.Random.nextInt(Random.java:390)</span><br><span class="line">    at TestRandom.main(TestRandom.java:12)</span><br></pre></td></tr></table></figure><p>如果线程栈中出现了 SecureRandom 相关的 locked 提示，那么阻塞原因很可能就与之相关。从上述栈信息可知，这是指定了 NativePRNGBlocking 算法的 SecureRandom 对象，在生成随机数时阻塞。阻塞时线程状态仍然为 RUNNABLE，因为 JVM 不会修改调用阻塞式 API 时阻塞的线程状态，这种阻塞仅仅能从系统层面观测到。</p><p>有常见的一种情况为 Tomcat 启动时阻塞，线程栈大致如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;main@1&quot; prio=5 tid=0x1 nid=NA runnable</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line">      at java.io.FileInputStream.readBytes(FileInputStream.java:-1)</span><br><span class="line">      at java.io.FileInputStream.read(FileInputStream.java:255)</span><br><span class="line">      at sun.security.provider.SeedGenerator$URLSeedGenerator.getSeedBytes(SeedGenerator.java:539)</span><br><span class="line">      at sun.security.provider.SeedGenerator.generateSeed(SeedGenerator.java:144)</span><br><span class="line">      at sun.security.provider.SecureRandom$SeederHolder.&lt;clinit&gt;(SecureRandom.java:203)</span><br><span class="line">      at sun.security.provider.SecureRandom.engineNextBytes(SecureRandom.java:221)</span><br><span class="line">      - locked &lt;0x1af3&gt; (a sun.security.provider.SecureRandom)</span><br><span class="line">      at java.security.SecureRandom.nextBytes(SecureRandom.java:468)</span><br></pre></td></tr></table></figure><p>从栈信息可知，这里使用了 SHA1PRNG 算法（<code>sun.security.provider.SecureRandom</code> 可知），但是种子生成器使用的是 URLSeedGenerator（准确点应该是 NativeSeedGenerator），在生成种子时由于熵池耗尽产生了阻塞问题。Tomcat 使用了 SecureRandom 的类为 <code>org.apache.catalina.util.StandardSessionIdGenerator</code>，具体代码在其抽象父类 <code>SessionIdGeneratorBase</code> 中。Tomcat 生成 sessionId 时，处于安全考虑，使用 SHA1PRNG 算法实现的 SecureRandom 类，在获取种子时产生阻塞。从代码的注释可知，Tomcat 选取 SHA1PRNG 作为默认算法的原因也颇为无奈：一来足够快，二来跨平台性最好。</p><p>解决阻塞问题的核心就是避免使用 <code>/dev/random</code>，可以通过工厂方法创建使用了非阻塞算法的对象，也可以修改系统配置，使用 <code>/dev/urandom</code> 作为种子源。根据实际情况灵活应变即可。</p><p>除此之外，还可以使用 Linux 的 haveged 守护进程进行噪声补充，保证熵池中随时都有足够资源。</p><h2 id="最佳实践"><a class="markdownIt-Anchor" href="#最佳实践"></a> 最佳实践</h2><h3 id="random-最佳实践"><a class="markdownIt-Anchor" href="#random-最佳实践"></a> Random 最佳实践</h3><p>了解过实现原理后，我们已知 Random 采取的是线程安全版的 LGC 算法，利用“循环 + CAS”的方式保证线程安全，可以在多个线程中使用一个 Random 对象。在并发性很高的情况下，“循环 + CAS”存在非常高的竞争，导致性能下降。因此现在更推荐使用线程本地存储的 <code>ThreadLocalRandom</code>。</p><p>ThreadLocalRandom 同样是一个伪随机数生成器，不支持构建函数创建，只能通过静态方法获取对象 <code>ThreadLocalRandom t = ThreadLocalRandom.current()</code>，使用与 Random 类似，但不支持设置种子。</p><p><code>current()</code> 方法获取到的对象为全局单例对象，也就是所有的线程获取到的实际上是同一个对象，但 ThreadLocalRandom 巧妙地将各线程本地状态存储在线程对象中，读写时再通过 Unsafe 类来操作，从而实现一个单例对象为不同线程提供服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalRandom</span> <span class="keyword">extends</span> <span class="title">Random</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unsafe 相关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe U = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED</span><br><span class="line">        = U.objectFieldOffset(Thread.class, <span class="string">&quot;threadLocalRandomSeed&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE</span><br><span class="line">        = U.objectFieldOffset(Thread.class, <span class="string">&quot;threadLocalRandomProbe&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocalRandom instance = <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (U.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果当前线程是第一次使用，则会进行一次种子初始化操作</span></span><br><span class="line">            localInit();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">        <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">        <span class="keyword">long</span> seed = RandomSupport.mixMurmur64(</span><br><span class="line">                seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// Unsafe 修改 t 对象的属性</span></span><br><span class="line">        U.putLong(t, SEED, seed);</span><br><span class="line">        U.putInt(t, PROBE, probe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用 nextXXX 方法时，都会从 Thread 对象中获取对应属性，修改后又会写回 Thread 对象中，让 Thread 对象承担了帮 ThreadLocalRandom 存储状态的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 类中的相关属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line">    <span class="meta">@jdk</span>.internal.vm.annotation.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line">    <span class="keyword">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line">    <span class="meta">@jdk</span>.internal.vm.annotation.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line">    <span class="keyword">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line">    <span class="meta">@jdk</span>.internal.vm.annotation.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line">    <span class="keyword">int</span> threadLocalRandomSecondarySeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以“抢红包”场景为例。设置红包总额和份数后，每次请求都会获取一个随机额度的红包。有很多方法可以实现这个功能，比如“预先分配”，创建红包时生成所有红包额度序列，请求时直接返回一个值即可；也可以“临时分配”，即每次请求时再临时计算单个红包额度。两者区别在于存储方面，预先分配的方式需要存储的数据更多，一个额度序列，以及记录当前未发出红包的指针，而临时分配仅需保存剩余金额和剩余个数，一个红包仅占一条记录，空间占用显然比前者小。</p><p>临时分配策略有很多种，一种比较符合情理的策略为：在 0.01 和剩余金额的两倍之间取一个随机值。这样不一定能保证公平，但能保证符合社会学的“公平分配”，毕竟不患寡而患不均，标准差才是重中之重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPacketAllocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取 1 到平均值的两倍之间的一个随机值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedPacketStrategy WX_STRATEGY = (total, count) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = total / count * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> money = (<span class="keyword">int</span>) (ThreadLocalRandom.current().nextDouble() * max);</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">1</span>, money);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedPacketStrategy strategy;</span><br><span class="line">    <span class="comment">/** 金额乘 100 保存 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftMoneyx100;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPacketAllocator</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(WX_STRATEGY, total, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPacketAllocator</span><span class="params">(RedPacketStrategy strategy,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> total, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        <span class="keyword">this</span>.leftMoneyx100 = total * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.leftCount = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">nextMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No money left.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> money = strategy.nextMoney(leftMoneyx100, leftCount);</span><br><span class="line">        leftMoneyx100 -= money;</span><br><span class="line">        leftCount--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> money / <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红包分配算法，计算下一个红包额度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedPacketStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据总额和份数计算下一个红包额度</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> total 总额</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> count 份数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> int 最小为 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">nextMoney</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="securerandom-最佳实践"><a class="markdownIt-Anchor" href="#securerandom-最佳实践"></a> SecureRandom 最佳实践</h3><p>SecureRandom 主要用在密码领域，最重要的一点就是要避免阻塞，可以根据具体场景采取不同的措施避免阻塞。其次则是可以定期对生成器进行一次种子注入，以提高安全性。</p><p>一个简单例子，敏感数据“加盐”场景。对于用户密码等敏感数据，需要进行“加盐”处理后再存储，这样能避免数据泄漏的风险。所谓盐者，就是一个随机数据，将密码与“盐”混合，然后进行一次哈希处理。存储数据时，仅存储“盐”值和哈希处理的结果，用户登录时重新进行一次加盐哈希，如果结果与数据库中记录匹配，则证明密码匹配。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>p</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mo stretchy="false">)</mo><mo>+</mo><mi>s</mi><mi>a</mi><mi>l</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hash(Hash(password) + salt)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span></p><p>以下代码展示了生成“盐”值的方式，调用方法达到一定次数后会进行一次 Reseed，补充生成器的随机度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] generateSalt() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == rng) &#123;</span><br><span class="line">        rng = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">        log.info(<span class="string">&quot;Initialized a random number stream using &#123;&#125; provided by &#123;&#125;&quot;</span>, rng.getAlgorithm(), rng.getProvider());</span><br><span class="line">        rngUses = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rngUses++ &gt; RESEED_INTERVAL) &#123;</span><br><span class="line">        <span class="comment">// 使用一定次数后，重新设置种子，增加安全性</span></span><br><span class="line">        log.debug(<span class="string">&quot;Re-seeding the RNG&quot;</span>);</span><br><span class="line">        rng.setSeed(rng.generateSeed(SEED_BYTES));</span><br><span class="line">        rngUses = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    salt = <span class="keyword">new</span> <span class="keyword">byte</span>[SALT_BYTES];</span><br><span class="line">    rng.nextBytes(salt);</span><br><span class="line">    <span class="keyword">return</span> salt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="end"><a class="markdownIt-Anchor" href="#end"></a> End</h2><p>从古老的龟甲占卜到现在各种彩票奖券，尽管世界越来越追求有序，人类仍在向混沌寻求某种希望，这也正是随机事件所具备的宿命感的魅力。</p><p>回到最初的问题，计算机掷骰子吗？相信此刻每一位读者已经有了答案。计算机和人脑一样，并不会凭空生成随机数，但可以借助数学工具，生成看似随机实则具备周期规律的伪随机数；还可以依赖客观世界中的不确定性，生成真随机数。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear congruential generator - Wikipedia</a></p><p>[2] <a href="https://tersesystems.com/blog/2015/12/17/the-right-way-to-use-securerandom/">The Right Way to Use SecureRandom · Terse Systems</a></p><p>[3] <a href="https://www.baeldung.com/java-secure-random">The Java SecureRandom Class | Baeldung</a></p><p>[4] <a href="https://hongjiang.info/java8-nativeprng-blocking/">再谈随机数引起的阻塞问题 | 夜行船</a></p><p>[5] <a href="https://cloud.tencent.com/developer/article/2016915">一个JAVA应用启动缓慢问题排查 --来自jdk securerandom 的问候 - 腾讯云开发者社区-腾讯云</a></p><p>[6] <a href="https://www.jb51.net/article/232584.htm">解决SecureRandom.getInstanceStrong()引发的线程阻塞问题_java_脚本之家</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Random </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2017/12/hello-world/"/>
      <url>2017/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> start </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
